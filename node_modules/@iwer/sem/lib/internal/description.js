/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
export var SemanticLabelJSON;
(function (SemanticLabelJSON) {
    SemanticLabelJSON["FLOOR"] = "FLOOR";
    SemanticLabelJSON["CEILING"] = "CEILING";
    SemanticLabelJSON["WALL_FACE"] = "WALL_FACE";
    SemanticLabelJSON["TABLE"] = "TABLE";
    SemanticLabelJSON["COUCH"] = "COUCH";
    SemanticLabelJSON["DOOR_FRAME"] = "DOOR_FRAME";
    SemanticLabelJSON["WINDOW_FRAME"] = "WINDOW_FRAME";
    SemanticLabelJSON["OTHER"] = "OTHER";
    SemanticLabelJSON["STORAGE"] = "STORAGE";
    SemanticLabelJSON["BED"] = "BED";
    SemanticLabelJSON["SCREEN"] = "SCREEN";
    SemanticLabelJSON["LAMP"] = "LAMP";
    SemanticLabelJSON["PLANT"] = "PLANT";
    SemanticLabelJSON["WALL_ART"] = "WALL_ART";
    SemanticLabelJSON["SCENE_MESH"] = "SCENE_MESH";
    SemanticLabelJSON["INVISIBLE_WALL_FACE"] = "INVISIBLE_WALL_FACE";
    SemanticLabelJSON["CHAIR"] = "CHAIR";
    SemanticLabelJSON["UNKNOWN"] = "UNKNOWN";
    SemanticLabelJSON["INNER_WALL_FACE"] = "INNER_WALL_FACE";
    SemanticLabelJSON["OTHER_ROOM_FACE"] = "OTHER_ROOM_FACE";
    SemanticLabelJSON["OPENING"] = "OPENING";
})(SemanticLabelJSON || (SemanticLabelJSON = {}));
function isVector2(obj) {
    return typeof obj.x === 'number' && typeof obj.y === 'number';
}
function isVector3(obj) {
    return (typeof obj.x === 'number' &&
        typeof obj.y === 'number' &&
        typeof obj.z === 'number');
}
function isQuaternion(obj) {
    return (typeof obj.x === 'number' &&
        typeof obj.y === 'number' &&
        typeof obj.z === 'number' &&
        typeof obj.w === 'number');
}
function isBounded2D(obj) {
    return isVector2(obj.offset) && isVector2(obj.extent);
}
function isBounded3D(obj) {
    return isVector3(obj.offset) && isVector3(obj.extent);
}
function isTriangleMesh(obj) {
    return (Array.isArray(obj.vertices) &&
        obj.vertices.every(isVector3) &&
        Array.isArray(obj.indices) &&
        obj.indices.every((index) => typeof index === 'number'));
}
function isPose(obj) {
    return isVector3(obj.position) && isQuaternion(obj.orientation);
}
function isLocatableComponent(obj) {
    return obj.hasOwnProperty('locatable') && isPose(obj.locatable);
}
function isBounded2DComponent(obj) {
    return obj.hasOwnProperty('bounded2D') && isBounded2D(obj.bounded2D);
}
function isBounded3DComponent(obj) {
    return obj.hasOwnProperty('bounded3D') && isBounded3D(obj.bounded3D);
}
function isSemanticLabelsComponent(obj) {
    return (obj.hasOwnProperty('semanticLabels') &&
        Array.isArray(obj.semanticLabels) &&
        obj.semanticLabels.every((label) => typeof label === 'string'));
}
function isTriangleMeshComponent(obj) {
    return obj.hasOwnProperty('triangleMesh') && isTriangleMesh(obj.triangleMesh);
}
function isSpatialEntityComponent(obj) {
    return (isLocatableComponent(obj) ||
        isBounded2DComponent(obj) ||
        isBounded3DComponent(obj) ||
        isSemanticLabelsComponent(obj) ||
        isTriangleMeshComponent(obj));
}
function isSpatialEntity(obj) {
    return (typeof obj.uuid === 'string' &&
        Array.isArray(obj.components) &&
        obj.components.every(isSpatialEntityComponent));
}
export function isValidSceneFile(obj) {
    return (obj.type === 'scene' &&
        typeof obj.version === 'number' &&
        Array.isArray(obj.spatialEntities) &&
        obj.spatialEntities.every(isSpatialEntity));
}
//# sourceMappingURL=description.js.map