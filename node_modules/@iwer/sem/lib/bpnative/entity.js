/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Mesh, MeshStandardMaterial } from 'three';
import { NativeMesh, NativePlane, XRRigidTransform } from 'iwer';
import { SemanticLabelJSON } from './description.js';
import { SpatialEntityComponentType, } from './components/component.js';
import { Bounded2DComponent } from './components/bounded2d.js';
import { Bounded3DComponent } from './components/bounded3d.js';
import { LocatableComponent } from './components/locatable.js';
import { SemanticLabelsComponent } from './components/semanticlabels.js';
import { TriangleMeshComponent } from './components/trianglemesh.js';
import { XRSemanticLabels } from 'iwer';
import { generateUUID } from 'three/src/math/MathUtils.js';
export var SpatialEntityType;
(function (SpatialEntityType) {
    SpatialEntityType["Plane"] = "plane";
    SpatialEntityType["Box"] = "box";
    SpatialEntityType["Mesh"] = "mesh";
})(SpatialEntityType || (SpatialEntityType = {}));
const WebXRSemanticLabelMap = {
    [SemanticLabelJSON.OTHER]: XRSemanticLabels.Other,
    [SemanticLabelJSON.TABLE]: XRSemanticLabels.Table,
    [SemanticLabelJSON.COUCH]: XRSemanticLabels.Couch,
    [SemanticLabelJSON.FLOOR]: XRSemanticLabels.Floor,
    [SemanticLabelJSON.CEILING]: XRSemanticLabels.Ceiling,
    [SemanticLabelJSON.WALL_FACE]: XRSemanticLabels.Wall,
    [SemanticLabelJSON.INVISIBLE_WALL_FACE]: XRSemanticLabels.Window,
    [SemanticLabelJSON.INNER_WALL_FACE]: XRSemanticLabels.Wall,
    [SemanticLabelJSON.DOOR_FRAME]: XRSemanticLabels.Door,
    [SemanticLabelJSON.WINDOW_FRAME]: XRSemanticLabels.Window,
    [SemanticLabelJSON.WALL_ART]: XRSemanticLabels.WallArt,
    [SemanticLabelJSON.STORAGE]: XRSemanticLabels.Shelf,
    [SemanticLabelJSON.BED]: XRSemanticLabels.Bed,
    [SemanticLabelJSON.LAMP]: XRSemanticLabels.Lamp,
    [SemanticLabelJSON.SCREEN]: XRSemanticLabels.Screen,
    [SemanticLabelJSON.PLANT]: XRSemanticLabels.Plant,
    [SemanticLabelJSON.SCENE_MESH]: XRSemanticLabels.GlobalMesh,
    [SemanticLabelJSON.CHAIR]: XRSemanticLabels.Couch,
    [SemanticLabelJSON.UNKNOWN]: XRSemanticLabels.Other,
    [SemanticLabelJSON.OTHER_ROOM_FACE]: XRSemanticLabels.Other,
    [SemanticLabelJSON.OPENING]: XRSemanticLabels.Other,
};
export class SpatialEntity extends Mesh {
    constructor(uuid = generateUUID()) {
        super(undefined, new MeshStandardMaterial({
            color: 0xffffff * Math.random(),
            flatShading: true,
        }));
        this.name = 'generic spatial entity';
        this.isSpatialEntity = true;
        this._componentMap = new Map();
        this._spatialUUID = uuid;
    }
    get spatialUUID() {
        return this._spatialUUID;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
    }
    addComponent(componentType, initData) {
        let component = null;
        switch (componentType) {
            case SpatialEntityComponentType.Locatable:
                component = new LocatableComponent(this, initData);
                break;
            case SpatialEntityComponentType.Bounded3D:
                component = new Bounded3DComponent(this, initData);
                break;
            case SpatialEntityComponentType.Bounded2D:
                component = new Bounded2DComponent(this, initData);
                break;
            case SpatialEntityComponentType.TriangleMesh:
                component = new TriangleMeshComponent(this, initData);
                break;
            case SpatialEntityComponentType.SemanticLabels:
                component = new SemanticLabelsComponent(this, initData);
                break;
        }
        if (component) {
            this._componentMap.set(componentType, component);
        }
    }
    getComponent(componentType) {
        return this._componentMap.get(componentType);
    }
    duplicate() {
        const clone = new SpatialEntity();
        this._componentMap.forEach((component, _k, _m) => {
            clone.addComponent(component.type, component.initData);
        });
        return clone;
    }
    get nativeEntity() {
        if (!this._nativeEntity) {
            const xrRigidTransform = new XRRigidTransform({
                x: this.position.x,
                y: this.position.y,
                z: this.position.z,
                w: 1,
            }, {
                x: this.quaternion.x,
                y: this.quaternion.y,
                z: this.quaternion.z,
                w: this.quaternion.w,
            });
            const semanticLabel = WebXRSemanticLabelMap[this.getComponent(SpatialEntityComponentType.SemanticLabels).semanticLabel];
            if (this.entityType === SpatialEntityType.Plane) {
                const { offset, extent } = this.getComponent(SpatialEntityComponentType.Bounded2D);
                const polygon = [
                    new DOMPointReadOnly(offset.x, 0, offset.y),
                    new DOMPointReadOnly(offset.x + extent.x, 0, offset.y),
                    new DOMPointReadOnly(offset.x + extent.x, 0, offset.y + extent.y),
                    new DOMPointReadOnly(offset.x, 0, offset.y + extent.y),
                    new DOMPointReadOnly(offset.x, 0, offset.y),
                ];
                this._nativeEntity = new NativePlane(xrRigidTransform, polygon, semanticLabel);
            }
            else if (this.entityType === SpatialEntityType.Box ||
                this.entityType === SpatialEntityType.Mesh) {
                const vertices = this.geometry.getAttribute('position')
                    .array;
                const indices = new Uint32Array(this.geometry.index.array);
                this._nativeEntity = new NativeMesh(xrRigidTransform, vertices, indices, semanticLabel);
            }
        }
        return this._nativeEntity;
    }
    static fromJSON(json) {
        const spatialEntity = new SpatialEntity(json.uuid);
        json.components.forEach((componentJson) => {
            const componentType = Object.keys(componentJson)[0];
            if (componentType) {
                const initData = componentJson[componentType];
                if (Object.values(SpatialEntityComponentType).includes(componentType)) {
                    spatialEntity.addComponent(componentType, initData);
                }
            }
        });
        return spatialEntity;
    }
    get entityType() {
        if (this.getComponent(SpatialEntityComponentType.Bounded2D)) {
            return SpatialEntityType.Plane;
        }
        else if (this.getComponent(SpatialEntityComponentType.Bounded3D)) {
            return SpatialEntityType.Box;
        }
        else if (this.getComponent(SpatialEntityComponentType.TriangleMesh)) {
            return SpatialEntityType.Mesh;
        }
        throw new DOMException('Unsupported entity type', 'NotSupportedError');
    }
    static toJSON(entity) {
        const json = {
            uuid: entity.spatialUUID,
            components: [],
        };
        entity._componentMap.forEach((value, _k, _m) => {
            json.components.push(value.toJSON());
        });
        return json;
    }
}
//# sourceMappingURL=entity.js.map