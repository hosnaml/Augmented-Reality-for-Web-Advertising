import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { ControlButtonStyles, ControlPanel, FAIcon, PanelHeaderButton, SectionBreak, } from './styled.js';
import { ControlsMapper, useKeyMapStore } from './mapper.js';
import { faCircleXmark, faGamepad, faGear, faPlug, } from '@fortawesome/free-solid-svg-icons';
import { AnalogButton } from './analog.js';
import { BinaryButton } from './binary.js';
import { Joystick } from './joystick.js';
import React from 'react';
import { Vector3Input } from './vec3.js';
function transformGamepadConfig(gamepadConfig) {
    const axesSet = new Set();
    // Add all axis ids to the set
    for (const axis of gamepadConfig.axes) {
        if (axis && axis.id) {
            axesSet.add(axis.id);
        }
    }
    // Transform buttons to the desired format
    const transformed = gamepadConfig.buttons
        .filter((button) => button !== null) // Filter out null values
        .map((button) => ({
        id: button.id,
        type: button.type,
        hasAxes: axesSet.has(button.id),
    }));
    // Sort the array by hasAxes
    transformed.sort((a, b) => {
        if (a.hasAxes && !b.hasAxes)
            return -1;
        if (!a.hasAxes && b.hasAxes)
            return 1;
        return 0;
    });
    return transformed;
}
export const ControllerUI = ({ controller, handle, handedness, pointerLocked, }) => {
    const { keyMap } = useKeyMapStore();
    const [connected, setConnected] = React.useState(controller.connected);
    const [settingsOpen, setSettingsOpen] = React.useState(false);
    const transformedConfig = transformGamepadConfig(controller.gamepadConfig);
    const actions = transformedConfig.flatMap((config) => {
        if (config.hasAxes) {
            return [
                `${config.id}-left`,
                `${config.id}-right`,
                `${config.id}-up`,
                `${config.id}-down`,
                config.id,
            ];
        }
        else {
            return config.id;
        }
    });
    React.useEffect(() => {
        if (pointerLocked) {
            setSettingsOpen(false);
        }
    }, [pointerLocked]);
    return (_jsxs(ControlPanel, { style: handedness === 'left'
            ? { left: '8px', bottom: '8px' }
            : { right: '8px', bottom: '8px' }, children: [!pointerLocked && (_jsx(_Fragment, { children: _jsxs("div", { style: {
                        display: 'flex',
                        flexDirection: 'row',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                    }, children: [_jsxs("div", { style: {
                                fontSize: '13px',
                                display: 'flex',
                                flexDirection: 'row',
                                alignItems: 'center',
                            }, children: [_jsx(FAIcon, { icon: faGamepad, style: { marginRight: '5px' } }), "Controller\u00A0", _jsxs("span", { style: { fontWeight: 'bold' }, children: ["[", handedness === 'left' ? 'L' : 'R', "]"] })] }), _jsx("div", { style: {
                                display: 'flex',
                                flexDirection: 'row',
                                gap: '1px',
                            }, children: connected ? (_jsxs(_Fragment, { children: [_jsx(PanelHeaderButton, { title: `Click to ${settingsOpen ? 'close' : 'change'} key bindings`, onClick: () => {
                                            setSettingsOpen(!settingsOpen);
                                        }, children: _jsx(FAIcon, { icon: faGear }) }), _jsx(PanelHeaderButton, { title: `Click to disconnect ${handedness} controller`, "$isRed": true, onClick: () => {
                                            controller.connected = false;
                                            setConnected(false);
                                        }, children: _jsx(FAIcon, { icon: faCircleXmark }) })] })) : (_jsx(PanelHeaderButton, { title: `Click to reconnect ${handedness} controller`, onClick: () => {
                                    controller.connected = true;
                                    setConnected(true);
                                }, style: { marginLeft: '5px' }, children: _jsx(FAIcon, { icon: faPlug }) })) })] }) })), connected && !pointerLocked && (_jsxs(_Fragment, { children: [!settingsOpen && (_jsxs(_Fragment, { children: [_jsx(SectionBreak, {}), _jsx(Vector3Input, { vector: handle.position, label: "Position", marginBottom: ControlButtonStyles.gap }), _jsx(Vector3Input, { vector: handle.rotation, label: "Rotation" })] })), _jsx(SectionBreak, {})] })), connected &&
                (settingsOpen ? (_jsx(ControlsMapper, { handedness: handedness, actions: actions })) : (transformedConfig.map((buttonConfig) => {
                    const mapping = keyMap[handedness];
                    if (buttonConfig.hasAxes) {
                        return (_jsx(Joystick, { xrController: controller, pointerLocked: pointerLocked, buttonId: buttonConfig.id, mappedKeyUp: keyMap[handedness][`${buttonConfig.id}-up`], mappedKeyDown: mapping[`${buttonConfig.id}-down`], mappedKeyLeft: mapping[`${buttonConfig.id}-left`], mappedKeyRight: mapping[`${buttonConfig.id}-right`], mappedKeyPressed: mapping[buttonConfig.id] }, buttonConfig.id));
                    }
                    else if (buttonConfig.type === 'analog') {
                        return (_jsx(AnalogButton, { xrController: controller, buttonId: buttonConfig.id, mappedKey: mapping[buttonConfig.id], pointerLocked: pointerLocked }, buttonConfig.id));
                    }
                    else {
                        return (_jsx(BinaryButton, { xrController: controller, buttonId: buttonConfig.id, mappedKey: mapping[buttonConfig.id], pointerLocked: pointerLocked }, buttonConfig.id));
                    }
                })))] }, handedness));
};
//# sourceMappingURL=controller.js.map