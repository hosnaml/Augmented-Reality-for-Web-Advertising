import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Button, ButtonContainer, ButtonGroup, ControlButtonStyles, FAControlIcon, FAIcon, MappedKeyBlock, } from './styled.js';
import { useEffect, useState } from 'react';
import { faChevronLeft, faChevronRight, faHandScissors, } from '@fortawesome/free-solid-svg-icons';
import { MappedKeyDisplay } from './keys.js';
const poses = ['default', 'point'];
const poseButtonWidth = `calc(2 * ${ControlButtonStyles.widthLong} - ${ControlButtonStyles.widthShort})`;
export const PoseSelector = ({ hand, pointerLocked, mappedKey, }) => {
    const [poseId, setPoseId] = useState(hand.poseId);
    const [isKeyPressed, setIsKeyPressed] = useState(false);
    const handedness = hand.inputSource.handedness;
    const cyclePose = (delta) => {
        const poseIdx = poses.indexOf(hand.poseId);
        const newPoseIdx = (poseIdx + poses.length + delta) % poses.length;
        setPoseId(poses[newPoseIdx]);
        hand.poseId = poses[newPoseIdx];
    };
    const layoutReverse = handedness === 'right';
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.code === mappedKey) {
                cyclePose(1);
                setIsKeyPressed(true);
            }
        };
        const handleKeyUp = (event) => {
            if (event.code === mappedKey) {
                setIsKeyPressed(false);
            }
        };
        if (pointerLocked) {
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
        }
        else {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        }
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        };
    }, [mappedKey, pointerLocked, hand]);
    return (_jsxs(ButtonContainer, { "$reverse": layoutReverse, children: [_jsx(FAControlIcon, { icon: faHandScissors, "$reverse": handedness === 'left' }), _jsx(ButtonGroup, { "$reverse": layoutReverse, children: pointerLocked ? (_jsx(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] })) : (_jsxs(_Fragment, { children: [_jsx(Button, { "$reverse": layoutReverse, style: {
                                width: ControlButtonStyles.widthShort,
                            }, onClick: () => {
                                cyclePose(layoutReverse ? 1 : -1);
                            }, children: _jsx(FAIcon, { icon: layoutReverse ? faChevronRight : faChevronLeft }) }), _jsxs(Button, { "$reverse": layoutReverse, style: {
                                width: poseButtonWidth,
                            }, disabled: true, children: ["Pose: ", poseId] }), _jsx(Button, { "$reverse": layoutReverse, style: {
                                width: ControlButtonStyles.widthShort,
                            }, onClick: () => {
                                cyclePose(layoutReverse ? -1 : 1);
                            }, children: _jsx(FAIcon, { icon: layoutReverse ? faChevronLeft : faChevronRight }) })] })) })] }));
};
//# sourceMappingURL=pose.js.map