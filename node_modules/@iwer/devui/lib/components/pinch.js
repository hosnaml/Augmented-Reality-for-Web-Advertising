import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Button, ButtonContainer, ButtonGroup, Colors, ControlButtonStyles, FAControlIcon, MappedKeyBlock, RangeSelector, } from './styled.js';
import { useEffect, useState } from 'react';
import { MappedKeyDisplay } from './keys.js';
import { faHandLizard } from '@fortawesome/free-solid-svg-icons';
const pinchSliderWidth = `calc(${ControlButtonStyles.widthLong} + ${ControlButtonStyles.widthShort} + ${ControlButtonStyles.gap})`;
export const PinchControl = ({ hand, pointerLocked, mappedKey, }) => {
    const [isPressed, setIsPressed] = useState(false);
    const [isKeyPressed, setIsKeyPressed] = useState(false);
    const [analogValue, setAnalogValue] = useState(0);
    const handedness = hand.inputSource.handedness;
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.code === mappedKey) {
                hand.updatePinchValue(1);
                setIsKeyPressed(true);
            }
        };
        const handleKeyUp = (event) => {
            if (event.code === mappedKey) {
                hand.updatePinchValue(0);
                setIsKeyPressed(false);
            }
        };
        const handleMouseDown = (event) => {
            if ((mappedKey === 'MouseLeft' && event.button === 0) ||
                (mappedKey === 'MouseRight' && event.button === 2)) {
                hand.updatePinchValue(1);
                setIsKeyPressed(true);
            }
        };
        const handleMouseUp = (event) => {
            if ((mappedKey === 'MouseLeft' && event.button === 0) ||
                (mappedKey === 'MouseRight' && event.button === 2)) {
                hand.updatePinchValue(0);
                setIsKeyPressed(false);
            }
        };
        if (pointerLocked) {
            if (mappedKey === 'MouseLeft' || mappedKey === 'MouseRight') {
                window.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mouseup', handleMouseUp);
            }
            else {
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
            }
        }
        else {
            if (mappedKey === 'MouseLeft' || mappedKey === 'MouseRight') {
                window.removeEventListener('mousedown', handleMouseDown);
                window.removeEventListener('mouseup', handleMouseUp);
            }
            else {
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
            }
        }
        return () => {
            if (mappedKey === 'MouseLeft' || mappedKey === 'MouseRight') {
                window.removeEventListener('mousedown', handleMouseDown);
                window.removeEventListener('mouseup', handleMouseUp);
            }
            else {
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
            }
        };
    }, [mappedKey, pointerLocked, hand]);
    return (_jsxs(ButtonContainer, { "$reverse": handedness === 'right', children: [_jsx(FAControlIcon, { icon: faHandLizard, "$reverse": handedness === 'left' }), _jsx(ButtonGroup, { "$reverse": handedness === 'right', children: pointerLocked ? (_jsx(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] })) : (_jsxs(_Fragment, { children: [_jsx(Button, { "$reverse": handedness === 'right', style: {
                                background: isPressed
                                    ? Colors.gradientLightGreyTranslucent
                                    : Colors.gradientGreyTranslucent,
                                width: ControlButtonStyles.widthLong,
                            }, onClick: () => {
                                setIsPressed(true);
                                hand.updatePinchValue(1);
                                setTimeout(() => {
                                    setIsPressed(false);
                                    hand.updatePinchValue(0);
                                }, 250);
                            }, children: "Pinch" }), _jsx(RangeSelector, { "$reverse": handedness === 'right', value: analogValue, onChange: (e) => {
                                const value = Number(e.target.value);
                                setAnalogValue(value);
                                hand.updatePinchValue(value / 100);
                            }, style: { width: pinchSliderWidth }, min: "0", max: "100" })] })) })] }));
};
//# sourceMappingURL=pinch.js.map