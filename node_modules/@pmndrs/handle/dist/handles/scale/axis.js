import { BoxGeometry, CylinderGeometry, Euler, Group, Mesh, MeshBasicMaterial } from 'three';
import { RegisteredHandle } from '../registered.js';
import { handleXRayMaterialProperties, setupHandlesContextHoverMaterial } from '../material.js';
import { extractHandleTransformOptions } from '../utils.js';
const normalRotation = new Euler(0, 0, -Math.PI / 2);
const invertedRotation = new Euler(0, 0, Math.PI / 2);
export class AxisScaleHandle extends RegisteredHandle {
    invert;
    showHandleLine;
    constructor(context, axis, tagPrefix = '', invert = false, showHandleLine = true) {
        super(context, axis, tagPrefix, () => ({
            scale: this.options,
            rotate: false,
            translate: 'as-scale',
            multitouch: false,
        }));
        this.invert = invert;
        this.showHandleLine = showHandleLine;
    }
    bind(defaultColor, defaultHoverColor, config) {
        const options = extractHandleTransformOptions(this.axis, config);
        if (options === false) {
            return undefined;
        }
        this.options = options;
        const rotation = this.invert ? invertedRotation : normalRotation;
        //visualization
        const visualizationHeadGroup = new Group();
        visualizationHeadGroup.position.x = this.invert ? -0.5 : 0.5;
        visualizationHeadGroup.rotation.copy(rotation);
        this.add(visualizationHeadGroup);
        const material = new MeshBasicMaterial(handleXRayMaterialProperties);
        const cleanupHeadHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
            color: defaultColor,
            hoverColor: defaultHoverColor,
        });
        const visualizationHeadMesh = new Mesh(new BoxGeometry(0.08, 0.08, 0.08), material);
        visualizationHeadMesh.renderOrder = Infinity;
        visualizationHeadMesh.rotation.copy(rotation);
        visualizationHeadGroup.add(visualizationHeadMesh);
        let cleanupLineHover;
        let visualizationLineMesh;
        let visualizationLineGroup;
        if (this.showHandleLine) {
            visualizationLineGroup = new Group();
            visualizationLineGroup.rotation.copy(rotation);
            this.add(visualizationLineGroup);
            const material = new MeshBasicMaterial(handleXRayMaterialProperties);
            cleanupLineHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
                color: defaultColor,
                hoverColor: defaultHoverColor,
            });
            visualizationLineMesh = new Mesh(new CylinderGeometry(0.0075, 0.0075, 0.5, 3), material);
            visualizationLineMesh.renderOrder = Infinity;
            visualizationLineMesh.position.y = 0.25;
            visualizationLineGroup.add(visualizationLineMesh);
        }
        //interaction
        const interactionGroup = new Group();
        interactionGroup.visible = false;
        interactionGroup.rotation.copy(rotation);
        interactionGroup.position.x = this.invert ? -0.3 : 0.3;
        this.add(interactionGroup);
        const interactionMesh = new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4));
        interactionMesh.pointerEventsOrder = Infinity;
        interactionMesh.position.y = 0.04;
        interactionGroup.add(interactionMesh);
        const unregister = this.context.registerHandle(this.store, interactionMesh, this.tag);
        return () => {
            material.dispose();
            interactionMesh.geometry.dispose();
            visualizationHeadMesh.geometry.dispose();
            visualizationLineMesh?.geometry.dispose();
            unregister();
            cleanupHeadHover?.();
            cleanupLineHover?.();
            this.remove(visualizationHeadMesh);
            if (visualizationLineGroup != null) {
                this.remove(visualizationLineGroup);
            }
            this.remove(interactionGroup);
            this.remove(visualizationHeadGroup);
        };
    }
}
